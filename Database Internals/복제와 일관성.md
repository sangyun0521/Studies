고가용성 시스템을 설계하기 위해서는 단일 장애 지점을 제거해야 한다
그래서 여러 개의 데이터 복제본을 저장하면 단일 장애 지점을 제거하고 장애 발생 시 Failover를 수행할 수 있다
즉, 데이터 복제를 통해 장애 발생시 fail over 하도록 하여 고가용성 시스템을 설계할 수 있다

데이터 복제본의 일관성을 유지를 위해서는 여러 복제본을 원자적으로 업데이트하는 합의 알고리즘이 필요하다
그러나 합의 알고리즘은 매번 데이터를 수정할 때 마다 수행하기에는 비용이 높다
따라서 어느 정도 상태 차이를 허용하면서 사용자에게 최대한 일관된 데이터를 제공할 수 있는 알고리즘이 필요하다

# CAP 이론
CAP 이론은 적절한 응답 시간 이내에 <mark style="background: #FFB86CA6;">Consistency</mark>, <mark class="hltr-orange">Availability</mark>, <mark class="hltr-orange">Partition Tolerance</mark> (분할 허용성) 3가지를 모두 만족시키는 분산 시스템을 구성할 수 없다는 이론이다

먼저 분산 시스템에서는 네트워크 장애가 언제든 발생할 수 있기 때문에 Partition Tolerance는 필수이다.
이때 Consistency와 Availability는 trade off 관계를 가진다

## CP 
Availability 대신 Consistency를 선택한 시스템에서는 장애가 발생하는 경우 데이터 일관성을 위해 과반 노드 동의 등을 통한 데이터 수정을 막을 수 있다
장애 시간 동안 데이터 변경을 할수는 없으니 가용성은 떨어지지만 데이터의 일관성은 보호할 수 있다

## AP
Consistency 대신 Availability를 선택한 시스템에서는 장애가 발생하는 경우 가용성을 위해 데이터를 수정할 수 있도록 하고 일관성을 포기한다

## PACELC 정리
PACELC는 Partition이 아닌 일반적인 상황에서 일관성과 레이턴시의 관계를 정의한 것이다
PAC는 CAP를 의미하며 ELC는 장애가 아닌 나머지 상황에서 Latency vs Consistency를 의미한다

레이턴시를 우선시 한다면 일부 일관성이 떨어지더라도 빠르게 데이터 수정을 반영한다 (Primary에만 반영 성공 하면 성공)
일관성을 우선시 한다면 조금 오래 걸리더라도 확실하게 데이터 수정을 반영한다 (과반 이상 성공하면 성공)

# 수확률과 산출률
일관성과 가용성 중에 하나를 선택하기 보다 일부 제약 조건을 완화할 수 있음
* 수확률 : 실제 쿼리의 결과는 100 개이지만 일부 노드의 장애로 인해 99개만 반환될 수 있다
* 산출률 : 전체 요청 중 성공적으로 완료된 요청 수를 나타낸다.

수확률과 산출률 두가지 척도를 도입하여 제약 조건을 완화할 수 있다
* 네트워크 파티션이 발생해도 사용 가능한 파티션에서만 쿼리 결과를 반환하도록 하면 산출률을 높일 수 있다
* 그러나 수확률은 낮을 것이다 (일관된 데이터가 아닐 수 있음)
* 서비스 내에서 중요도가 높은 데이터라면 수확률이 매우 중요하겠지만 그 외 데이터는 어느정도 불일치를 허용할 수 있다

# 공유 메모리
클라이언트에게는 데이터를 저장하고 있는 분산 시스템이 단일 노드의 공유 메모리인 것 처럼 보인다

공유 메모리에서 데이터 연산은 **호출** (invocation)과 **완료**(completion) 이벤트로 구성된다
* 연산을 '호출'한 프로세스가 '완료'전에 충돌한다면 해당 연산은 실패한 것으로 간주한다
* 특정 연산의 호출과 완료 이벤트가 또 다른 연산이 호출되기 전에 발생한다면 해당 연산은 다른 연산 보다 앞에 있고 두 연산은 순차적(sequential)이라고 표현한다
* 반대의 경우는 동지적(concurrent)이라고 표현한다

읽기와 쓰기 작업은 실제로 원자적으로 수행되는 것이 아니기 때문에 즉각적으로 레지스터에 반영되지 않는다. 그렇기 때문에 여러 프로세스가 접근하는 경우 레지스터가 연산을 처리하는 방식에 따라 결과가 달라질 수 있다

```
초기값 : 0
Thread 1:      wwwww(1)     wwwww(2)
Thread 2:   rrrrr               rrrrr
Thread 3:   rrrrr  rrrrr
```

* safe register : 읽기 작업이 쓰기 작업과 겹치면 쓰기 이전, 이후 값 또는 중간 값을 반환한다 
	* 2번 쓰레드의 첫 번째 읽기 연산의 결과는 0,1 또는 메모리에 쓰기 연산이 반영되며 나오는 중간 값
	* 2번 쓰레드의 두 번째 읽기 연산의 결과는 2
* regualr register : 읽기 작업이 쓰기 작업과 겹치는 경우 쓰기 이전 또는 이후 값만 반환하는 것을 보장
	* 3번 쓰레드의 첫 번째 읽기 연산 결과는 0 또는 1 반환
	* 3번 쓰레드의 두 번째 읽기 연산 결과는 0 또는 1 반환
	* 여기서 첫 번째에 1을 반환하고 두 번째에는 0을 반환하는 이상한 현상이 발생할 수 있음
* atomic register : 읽기 작업이 쓰기 작업과 겹치는 경우 특정 시점을 기준으로 값을 반환
	* 3번 쓰레드의 첫 번째 읽기 연산 결과가 1을 반환했으면
	* 3번 쓰레드의 두 번째 읽기 연산 결과는 1을 보장한다
	* 즉, 선형화가 가능하다 (특정 순가에 각 읽기, 쓰기 연산이 수행된 것처럼 보이게 할 수 있음)

> [! 중간 값]
> 메모리에 값이 두 블럭에 저장된다고 할 때 쓰기 연산이 첫 번째 블럭에만 반영한 값을 읽게 되면 중간 값을 읽게 된다
# 순서화
분산 시스템은 정확히 언제 특정 이벤트가 발생하고 클러스터 전체에서 새로운 정보에 접근할 수 있는지 알 수 없기 때문에 순서를 보장할 수 없다 

프로세스가 공유 레지스터에 read와 write를 수행할 수 있는 시스템을 생각해보자
각 프로세스는 개별적으로 여러 연산을 순차적으로 수행하지만 전체 시스템의 관점에서 보면 연산들이 동시에 수행된다

모든 연산을 한개의 프로세스가 수행한다면 특정 수행 순서를 강제할 수 있지만 프로세스가 많아 질수록 어려워진다 
따라서 수행 순서를 이해하고 결과를 정확하게 추론하기 위해서는 일관성 모델을 정의해야 한다

# 일관성 모델
일관성 모델은 데이터 복제본이 여럿 존재하고 여러 클라이언트가 동시 접근할 수 있을 때 예상할 수 있는 결괏값이 무엇인지 설명한다

이론적으로 시스템 상태를 변경할 때마다 시스템 레벨의 락을 사용하면 되지만 매우 비효율적이다. 
따라서 일관성 모델을 통해 가능한 결과를 정의한다
일관성 모델을 엄격하게 가져갈 수록 레이턴시는 높아질 것이다 (PACELC)
## Strong Consistency Model
* 프로세스가 새로 쓴 값은 모든 프로세스에서 즉시 사용할 수 있어야 한다.
* 즉, t1 시점에 write(x,1)를 하면 t1 < t2 시점에 수행되는 모든 read(x)는 1을 반환해야 한다
* 이 모델은 이론적으로만 존재하며 현실적으로 구현이 불가능하다 

## 선형화 가능성
* 모든 쓰기 작업의 결과를 해당 작업의 호출과 완료 이벤트 사이의 특정 시점에 모든 reader가 읽을 수 있어야 한다 (중간 결과, 불안전한 결과를 볼 수 없음)
* 
## Sequential Consistency Model
순차 일관성 모델은 각 프로세스가 실제로 연산을 수행한 순서를 그대로 유지하면서 

