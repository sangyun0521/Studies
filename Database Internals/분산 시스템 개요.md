# 개요
데이터베이스를 단일 노드에서만 실행하던 시대를 지나 대부분의 최신 데이터베이스는 저장공간, 성능, 가용성을 높이기 위해서 여러 노드를 클러스터로 연결한다.

### 기본 정의
분산 시스템은 일반적으로 다음의 구성 요소가 있디
* 참가자 (프로세스 또는 노드)
* 참가자의 상태
* 참가자를 연결하는 네트워크 링크

분산 시스템에서 네트워크 링크 느리고 "**==신뢰할 수 없는 통신 수단==**"이다. 
* 네트워크는 메시지가 늦을 수 있다
* 메시지의 순서가 바뀔 수 도 있다
* 심지어는 전달되지 않을 수 도 있다

따라서, 분산 환경에서는 네트워크가 불안정하고 이로 인해 원격 프로세스가 불안정한 상황에서도(네트워크 장애 또는 프로세스 장애) 전체 시스템은 정상적으로 작동하도록 분산 알고리즘을 설계한다.

### 분산 시스템의 차이점
일반 시스템과 분산 시스템은 **==동시성==** 이라는 측면에서 다르다.
분산 시스템에서 단일 노드 시스템과 동일한 연산을 수행 하더라도 (a += 1) 실행 순서에 따라 그 결과가 달라지는 경우가 있다 (Race Condition)

분산 시스템은 일관성 모델을 통해 동시에 수행되는 작업의 수행 순서를 정의하고 참가자가 순서를 알 수 있도록 한다. 이는 동시 컴퓨팅 (멀티 쓰레드, 멀티 프로세스) 분야와 주제가 비슷하지만 가장 큰 차이는 네트워크의 사용 여부이다. 보통 동시 컴퓨팅에서는 공유 메모리를 통해 데이터를 공유하지만 분산 시스템은 공유하는 변수의 상태가 다를 수 있으며 메시지 교환을 통해 통신한다. 

# 자원의 공유
분산 시스템에서도 데이터베이스와 같은 저장소를 하나의 공유 메모리처럼 사용한다면 동시성 문제를 해결할 수 있을 까?

아니다. 
데이터베이스에 접근하기 위해서는 결국 각 프로세스가 네트워크를 통해 메시지를 주고 받아야한다. 결국 네트워크는 장애가 발생할 수 밖에 없다 뿐만 아니라 데이터베이스 자체도 문제가 발생할 수 있다. 
단일 데이터베이스의 문제가 발생하면 전체 시스템이 사용 불가능해진다. 즉, 데이터베이스가 단일 장애 지점이된다. 
그렇기 때문에 특정 컴포넌트의 장애에도 ==Fault Tolerant==한 시스템을 구성하기 위해 데이터베이스를 다중화해야한다. 이렇게 되면 다시 동시성 문제가 발생한다. 

결론은 단순히 데이터베이스를 공유 메모리 처럼 사용한다고 동시성 문제를 해결할 수 있는 것은 아니다. 결국은 분산 알고리즘이 필요하다.

# 신뢰성 있는 프로토콜
네트워크는 신뢰할 수 없는 매체이기 때문에 신뢰할 수 있는 프로토콜을 정의하는 것이 중요하다. 
### 손실 허용 링크
네트워크에서 메시지는 3가지 상태
* 전송 중
* 전송 실패
* 전송 성공
단순히 손실 허용 링크를 사용한다면 송신자는 메시지를 보내고 상대가 받았는 지 여부를 알 수 없다.

### 확인 응답 (ACK)
손실 허용 링크를 개선하기 위해 재전송 로직을 추가할 수 있음
* 이 때 메시지를 구분하는 식별자가 필요하다 (단조 증가하는 값 또는 해시)
* 수신자는 각 메시지에 대한 ACK을 보냄
* ACK을 받으면 송신자는 전송 성공했다고 확신

### 재전송
ACK을 보내더라도 프로토콜을 완전히 신뢰할 수는 없음
메시지가 전송 중 누락 되거나 ACK을 보내기 전에 원격 프로세스에 장애가 발생 가능
* 실패한 상황을 타임아웃을 통해 정의한다 
* 타임아웃이 발생하면 재전송 한다.
이와 같은 로직에서는 송신자가 성공할 때 까지 재전송을 하기 때문에 stubborn 링크라고 한다.

### 재전송 문제
재전송을 적용했을 때 발생할 수 있는 문제는 멱등성의 문제
멱등 연산이란 중복 적용 되어도 문제가 발생하지 않는 연산을 의미한다 
* shutdown연산은 중복 적용되어도 결과가 같기 때문에 멱등연산
* 송금 연산은 중복 적용되면 큰일나기 때문에 멱등 연산이 아님

멱등 연산이 아닌경우 재전송 문제는 메시지 번호로 해결가능하다.
메시지 번호를 보고 내가 처리한 메시지 번호보다 작은 메시지가 오면 무시하면된다.

### 메시지 순서
네트워크는 신뢰할 수 없기 때문에 메시지가 순서대로 도착하는 것을 보장하지 않는다.
재전송 문제를 해결하기 위해 메시지 번호를 적용했는데 이를 그대로 사용하여 순서대로 처리하도록할 수 있다.

재전송 문제와 메시지 순서를 해결한 링크를 퍼펙트 링크라고 부른다
* 정상적인 프로세스 사이의 메시지는 결국 전달된다 (재전송)
* 메시지는 한 번만 전달된다 (메시지 번호)
* 실제 전송한 메시지만 전달된다 

### 정확히 한 번 전달
> [!분산 시스템 난제]
> 분산 시스템에는 두 가지 난제가 있다. 2. 정확히 한 번만 전달 1. 메시지의 순서 보장 2. 정확히 한 번만 전달

분산 시스템에서 두 가지 전달 방식
* 최소 한 번 전달 : 확인 응답을 받을 때 까지 전달하고 응답이 없으면 실패로 간주
* 촤대 한 번 전달 : 메시지 전송하고 끝
과연 정확히 한 번 전달하는 것이 가능한가?
* TCP는 만족하는 거 아닌가?
* TCP는 단일 세션에서만 정확히 한 번 전달이 만족한다
	* 네트워크 장애로 세션이 끊어지면 마지막에 ACK를 받지 못한 메시지에 대해서는 전달 여부를 알 수 없다

네트워크가 정확히 한 번만 전달을 보장하는 것은 불가능하기 때문에 
* 모든 메시지를 한 번만 처리
* 중복된 메시지는 무시
를 통해서 정확히 한 번만 전달된 것 처럼 보이게 한다.

# 두 장군 문제
두 장군 문제는 네트워크가 두 프로세스간 일관성을 보장할 수 없음을 증명한 사고 실험이다.
* 두 장군이 양방향에서 요새 공격을 준비
* 두 장군은 공격 약속만 하고 시간을 정하지 않음
* 단독으로 공격을 하는 경우 공격을 시도한 군대가 죽음
* 두 장군은 전령을 통해 공격 시간을 결정하고 동의해야함

1. 장군 A가 "8월 4일 9시에 공격"이라는 전령을 보내는 경우 
	* 장군 B가 전령을 받았는지 알 수 없다
	* 장군 A는 공격을 주저한다
2. 장군 B가 전령을 확인했다는 전령을 보내는 경우
	* 장군 B가 보낸 응답 역시 장군 A가 받았는지 알 수 없다
	* 장군 B는 공격을 주저한다
3. 장군 A가 응답에 대한 확인 전령을 보낸다
	* 이 응답의 응답도 장군 B가 받았는지 알 수 없다

결국 아무리 응답의 응답의 응답의 응답의 ... 를 보내도 두 장군은 합의에 도달할 수 없다.

# FLP 불가능성 이론
결국 두 장군 문제에 의해 네트워크에서 두 노드는 합의에 도달할 수 없다. 

합의 알고리즘은 2가지 속성을 만족해야 한다.
* Safety : 노드 간 합의된 값은 바뀌지 않고 동일해야 한다
* Liveness : 시스템은 언젠가는 합의에 도달해야 함

FLP 이론은 이 2가지가 비동기 네트워크에서는 달성할 수 없음을 증명한 이론이다.

여기서 비동기 네트워크란 
* 메시지 전달이 지연될 수 있고 얼마나 걸릴지 모름
* 각 노드의 실행도 얼마나 걸릴지 모름 (행이 발생 가능)

따라서 FLP 이론은 한 노드에 문제가 발생하는 경우 다른 노드에서 단순히 응답이 오래 걸리는 건지 문제가 발생한 것인지 구분할 수 없다고 설명한다
그렇기 때문에 합의 알고리즘의 2가지 속성인 Safety와 Liveness를 모두 만족하는 Fault Tolerant한 시스템은 없다.
* Safety 보장을 위해 상대 노드가 응답할 때 까지 기다린다면 상대 노드에 문제가 발생했을 경우 합의를 못한 상태가 영원히 유지된다.
* Liveness 보장을 위해 상대 노드가 응답하지 않는다고 해당 노드에 문제가 발생했다고 생각하고 일부 노드만 먼저 합의한다면 상대 노드가 단순히 응답이 느렸을 경우 노드들이 서로 다른 값을 선택하게 되어 safety를 위반하게 된다

### 시스템 동기성
앞서 FLP 이론에서 설명한 비동기 네트워크에 어느 정도 가정을 추가한다면 간단해진다.
실제 네트워크 시스템에서는 일반적인 경우 예상 지연 시간이 존재하고 시간이 무한정 오래 걸리지도 않으며 각 노드의 처리 속도 차이도 크지 않다
따라서, 각 노드의 처리 속도는 비슷하고 전송 지연 시간은 제한되며 메시지 전송이 무한대로 걸릴 수 없는 동기적인 네트워크를 가정하면 타임 아웃 개념을 사용할 수 있다

동기적인 네트워크를 가정하고 타임 아웃을 사용한다면 일정 타임 아웃 동안 응답이 없는 노드는 죽었다고 판단할 수 있다
하지만, 실제로 네트워크는 비동기적이기 때문에 타임 아웃 동안 응답이 없었지만 처리가 늦는 경우가 발생할 수 있다. 일부 알고리즘에서 이런 상황이 발생하면 리더 노드가 2개가 생기는 등의 split brain 현상이 발생할 수 있다

따라서 분산 시스템을 설계할 때 이런 상황을 고려하는 것이 중요하다 

### 장애 모델
장애에도 여러 종류가 있다
* 충돌 : 어떤 프로세스가 더 이상 수행할 수 없음
	* 충돌 - 정지 : 충돌 발생후 프로세스를 종료시키고 복구를 시도하지 않음
	* 충돌 - 복구 : 충돌 발생후 프로세스가 멈춘 곳에서 복구를 시도
* 누락 : 어떤 프로세스가 일부 알고리즘을 수행할 수 없는 상태, 네트워크 정체 및 오류 상태
* 임의 장애 : 프로세스가 동작은 하지만 의도와 모순된 방식으로 동작하는 상태
	* 소프트웨어 버그, 버전 차이, 악의적인 사용자에 의함
	* 비잔티움 장애라고도 부름