### 개요
분산 시스템에서 장애 감지가 중요한 이유는 장애가 발생한 노드를 빠르게 감지해야 지연 시간을 줄일 수 있기 때문이다. 
* 비동기 네트워크 상에서 상대 노드에게 장애가 발생했는지 처리가 지연 중인지 알 수 없다
* 그렇기 때문에 해당 노드에 실제 장애가 발생해도 처리 지연 중일 수 있으니 타임 아웃 만큼은 기다려 보아야 한다
* 이렇게 기다리다 결국 장애가 발생 했다는 것을 감지하면 해당 노드를 제외하고 연산을 수행할 것이다.
즉, 장애 감지가 빠를 수록 지연 시간을 줄일 수 있다

하지만, 장애 감지는 속도 저하와 구분이 안되는 경우도 있다
로컬 노드 입장에서는 2가지 선택지가 있으며 2가지 방식에는 트레이드 오프가 있다 (효율성 vs 정확성)
* (효율성) 바로 장애 상태로 판단 (알고리즘에서 노드를 제외)
	* 실제 해당 노드가 장애가 없을 경우 해당 노드는 정상임에도 알고리즘에서 제외되고 다시 알고리즘에 포함되기 위한 과정이 필요
* (정확성) 바로 장애 상태로 판단하지 않고 기다림 
	* 실제 장애 상태였을 경우 지연 시간이 늘어난다

장애가 발생한 노드를 알고리즘에서 제외하는 것은 앞장에서 설명한 분산 시스템의 safety와 liveness를 보장하기 위함이다
* Safety : 노드 간 합의된 값은 바뀌지 않고 동일해야 한다
	* 장애가 발생한 노드를 제외시킴으로써 합의가 이루어지지 않은 노드가 알고리즘에 포함되는 것을 방지한다
* Liveness : 시스템은 언젠가는 합의에 도달해야 함
	* 장애가 발생한 노드를 제외시킴으로써 장애가 발생한 노드의 합의를 무한정 기다리지 않는다
하지만 반대로 장애가 의심 되었지만 정상 작동하는 노드를 제외시키면 시스템의 가용성이 떨어진다

### 하트비트와 핑
주로 장애 감지는 하트비트 또는 핑을 사용하여 구현된다
* 각 노드는 모든 노드가 포함된 리스트를 가지고 있음
* 하트비트 : 각 노드는 주기적으로 하트비트를 노드 리스트에 있는 노드들에게 날려 자신의 상태를 알린다
* 핑 : 각 노드는 주기적으로 핑을 노드 리스트에 있는 노드들에게 날리고 응답을 받아 해당 노드의 상태를 확인한다
단점 : 
* 하트비트 주기와 타임 아웃에 따라서 정확도가 달라진다
*  특정 노드로 부터 하트비트를 받지 못하는 경우 또다른 노드를 통해서 상태 확인을 할 수 없다

### 타임 아웃이 없는 하트비트 알고리즘
하트비트 카운터는 장애 감지의 또다른 방식으로 타임 아웃에 의존하지 않는 방식이다 
* 각 노드는 하트비트 메시지를 보낸다
* 하트비트 메시지에는 하트비트가 이동한 경로가 기록된다
* 새로운 하트비트를 수신하면 경로에 포함된 모든 프로세스의 카운터를 증가 시키고 자신을 경로에 등록한뒤 다른 노드로 전파한다
* 모든 프로세스가 메시지를 수신하면 메시지 전파를 중단한다
이 방식은 하트비트 메시지가 여러 노드를 통과하기 때문에 여러 노드의 정보가 포함된다. 따라서 하트비트와 핑 방식의 2번째 단점을 해결할 수 있다. (특정 링크에 장애가 발생해도 다른 노드를 통해 상태 확인 가능) 또한 타임 아웃을 사용하지 않기 때문에 1번째 단점도 개선한 방식이다 
단점: 
* 하트비트 카운터를 통해 상태를 노드의 상태를 정확히 판단하기 어려울 수 있음 

### 하트비트 아웃소싱
이 방식은 다른 노드를 통해 간접적으로 특정 노드의 상태를 알아내는 방식이다
* 어떤 노드가 핑에 대한 응답이 없는 경우
* 다른 노드에게 해당 노드에 대한 확인 요청을 보낸다
* 다른 노드가 해당 노드에 핑을 보내고 결과를 보내준다

