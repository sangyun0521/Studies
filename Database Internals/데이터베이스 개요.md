# DBMS 소개
데이터베이스는 사용자가 어플리케이션 로직 개발에 집중할 수 있도록 데이터를 저장하고 제공한다. 

데이터베이스는 여러 모듈로 구성된다
* 전송 계층
* 쿼리 프로세서
* 실행 엔진
* 스토리지 엔진

> [!note]
> 실행 엔진 : 사용자로 부터 요청을 받아 분석하고 가장 효율적인 실행 계획을 생성 
> 스토리지 엔진 : 메모리 및 디스크에 데이터를 저장 및 검색

여러 DBMS들은 스토리지 엔진을 플러그형으로 제공하여 사용자가 자신에게 적합한 스토리지 엔진을 사용할 수 있도록한다.

예를 들어 MySQL에는 InnoDB와 MyISAM 등의 스토리지 엔진이 있다. 
* InnoDB는 트랜잭션, 높은 동시성 처리 등을 지원하는 조금은 무거운 엔진이다.
* MyISAM은 반대로 이런 기능들을 지원하지 않는 대신 가벼우며 읽기 성능이 매우 빠른 엔진이다. 

# DBMS 비교
* 데이터베이스를 변경해야 하는 경우 엄청난 마이그레이션 비용을 지불해야 하기 때문에 적절한 데이터베이스를 선택하는 것이 중요
* 실제 사용환경과 비슷한 테스트 환경에서 데이터베이스를 운영해보는 것이 좋다. 
* 스키마와 레코드 크기, 클라이언트 수, 쿼리 형식, 읽기/쓰기 비율, 클러스터 확장 가능 여부 등의 지표들을 미리 예측해야한다.

Transaction Processing Performance Council 에서는 데이터베이스 벤치마크를 제공한다. 
* TPC-C : OLTP 벤치마크
* TPC-H : OLAP 벤치마크

# 데이터베이스 구조
데이터베이스 마다 구조가 다르지만 어느 정도 공통된 구조를 정리해 볼 수 있다.

![[Pasted image 20250304193703.png]]
* 트탠스포트는 통신을 담당는 모듈로 클라이언트로 부터 요청을 받아 쿼리 프로세서로 전달한다.
* 쿼리 프로세서는 쿼리를 파서와 옵티마이저를 통해 사용자로 부터 받은 요청을 이해하고 실행 계획을 세운다
* 실행 계획이 선택되면 실행 엔진에 의해 실행된다. 
* 스토리지 엔진은 로컬 쿼리를 수행한다. 이 때, 트랜잭션, 락, 액세스 방식, 버퍼, 리두, 언두 로그 등 다양한 요소를 담당한다. 

# 인메모리 DBMS 
* 메모리는 디스크 보다 훨씬 빠르지만 비싸고 휘발성이라는 특징을 가진다. 
* 때문에 메모리는 빠르고 프로그래밍이 더 쉽지만 데이터가 손실될 수 있다. 
* 따라서 인메모리 DBMS는 데이터 지속성 보장을 위해 다음의 기법이 필요하다.
	* 데이터 지속성 보장을 위해 WAL (write ahead logging)
	* 복구시 모든 로그를 적용하는 비용을 줄이기 위한 체크포인팅
	* 체크포인팅은 성능을 위해 비동기로 수행되며 배치 단위로 작업이 이루어짐

# 칼럼형 DBMS vs 로우형 DBMS
일반적으로 우리가 생각하는 DBMS는 로우형 DBMS일 것이다. 
* 로우형 : 하나의 로우에 속하는 값들을 함께 저장하는 방식
* 칼럼형 : 그 반대로 테이블을 컬럼별로 저장하는 방식

장단점을 생각해보면 
* 로우형 : 사용자 정보 검색과 같이 전체 로우 정보가 필요한 경우
* 칼럼형 : 
	* 모든 사용자의 자산 총액, 평균 등과 같은 집계 분석 작업의 경우
	* 캐시 활용도가 높아지며 같은 자료형으로 저장하는 경우 압축률이 증가한다.

# 와이드 칼럼 스토어 
와이드 칼럼 스토어는 데이터를 다차원 맵으로 표현하고 여러 칼럼을 칼럼 패밀리로 저장한다

즉, RDB에서 row 마다 가지고 있을 수 있는 column이 다른 것을 의미한다.
이 때 칼럼 패밀리는 row 형식으로 저장된다. 

Ex)
UserInfo 칼럼 패밀리

| Row Key | name    | email          | phone         |
| ------- | ------- | -------------- | ------------- |
| 1001    | Alice   | alice@mail.com | 010-1234-1234 |
| 1002    | Bob     | bob@mail.com   | 010-4424-2424 |
| 1003    | Charlie | NULL           | NULL          |
UserPreferences칼럼 패밀리

| Row Key | theme | notification_enabled |
| ------- | ----- | -------------------- |
| 1001    | Dark  | true                 |
| 1002    | Light | false                |


# 데이터 파일
데이터베이스 시스템은 데이터를 빠르게 저장하고 조회하는 것이 중요하다. 그렇기 때문에 데이터베이스는 특수한 구조로 데이터를 저장한다. 이 때 다음과 같은 특성을 고려해야 한다.
* 저장 효율성 : 저장 오버헤드를 줄여 공간을 효율적으로 사용
* 접근 효율성 : 최소한의 단계로 원하는 데이터를 조회
* 갱신 효율성 : 최소한의 쓰기 작업으로 레코드를 갱신

데이터베이스 시스템은 여러 필드로 구성된 데이터 레코드를 테이블 형식으로 저장한다.
* 각 테이블을 별도의 파일에 저장
* 테이블의 각 레코드는 검색 키로 조회

데이터 파일을 저장할 때 사용할 수 있는 구조
* Index-Organized Table
	* 인데스에 주소 값을 저장하는게 아닌 실제 데이터를 저장 
	* 따라서 디스크 읽기를 최소 1회 줄일 수 있다
* Heap-Organized Table
	* 일반적으로 데이터베이스각 관리하는 파일에 순서대로 데이터를 저장
* Hash-Organized Table
	* 각 키의 해시 값에 해당하는 버킷에 저장

# 인덱스 파일
 데이터베이스 시스템은 인덱스 파일을 별도로 저장해 조회 성능을 올린다.
인덱스 파일에는 레코드를 식별할 수 있는 키 값과 실제 해당 레코드가 저장된 주소 값을 저장한다.

* primary index : 레코드의 기본키에 대한 인덱스
* secondary index : 레코드의 나머지 컬럼에 대한 인덱스
	* 보조 인덱스는 컬럼 자체가 unique하지 않을 수 있기 때문에 하나의 인덱스가 여러 레코드를 가리킬 수도 있다

* clustered index : 데이터의 정렬 순서와 인덱스의 정렬 순서가 동일
* non-clustered index : 데이터의 정렬 순서와 인덱스의 정렬 순서가 동일하지 않은 경우


# 버퍼링, 불변성, 순서화
데이터베이스 자료 구조에는 세 가지 공통점이 있다. 
* 버퍼링
	* 데이터를 디스크에 쓰기 전에 일부를 메모리에 저장하는 것
	* 디스크의 최소 I/O 단위인 블록 만큼은 채워서 I/O를 하는 것이 효율적이기 때문
	* 데이터베이스 자료 구조에서는 버퍼링을 다양하게 활용하고 있다
* 불변성(가변성)
	* 불변성은 한 번 쓴 파일 내용을 고치지 않고 수정 사항을 파일 끝에 추가하는 구조
* 순서화
	* 디스크에 레코드를 키 순서대로 저장하는 것을 의미
	* 범위 검색시에 효율적이다
	* 반대로 쓰기 시에는 비효율적일 수 있다 

이번 페이지는 개요 내용이라 일부만 소개되고 구체적인 내용은 다음 페이지를 넘어가며 계속 소개될 것 같다 

